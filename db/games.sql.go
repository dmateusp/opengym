// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const gameCountByUser = `-- name: GameCountByUser :one
select count(*)
from games
where organizer_id = ?
`

func (q *Queries) GameCountByUser(ctx context.Context, organizerID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, gameCountByUser, organizerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const gameCreate = `-- name: GameCreate :one
insert into games(
  id,
  organizer_id,
  name,
  description,
  published_at,
  total_price_cents,
  location,
  starts_at,
  duration_minutes,
  max_players,
  max_waitlist_size,
  max_guests_per_player
) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
returning id, organizer_id, name, description, published_at, total_price_cents, location, starts_at, duration_minutes, max_players, max_waitlist_size, max_guests_per_player, created_at, updated_at
`

type GameCreateParams struct {
	ID                 string
	OrganizerID        int64
	Name               string
	Description        sql.NullString
	PublishedAt        sql.NullTime
	TotalPriceCents    int64
	Location           sql.NullString
	StartsAt           sql.NullTime
	DurationMinutes    int64
	MaxPlayers         int64
	MaxWaitlistSize    int64
	MaxGuestsPerPlayer int64
}

func (q *Queries) GameCreate(ctx context.Context, arg GameCreateParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, gameCreate,
		arg.ID,
		arg.OrganizerID,
		arg.Name,
		arg.Description,
		arg.PublishedAt,
		arg.TotalPriceCents,
		arg.Location,
		arg.StartsAt,
		arg.DurationMinutes,
		arg.MaxPlayers,
		arg.MaxWaitlistSize,
		arg.MaxGuestsPerPlayer,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.OrganizerID,
		&i.Name,
		&i.Description,
		&i.PublishedAt,
		&i.TotalPriceCents,
		&i.Location,
		&i.StartsAt,
		&i.DurationMinutes,
		&i.MaxPlayers,
		&i.MaxWaitlistSize,
		&i.MaxGuestsPerPlayer,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const gameGetById = `-- name: GameGetById :one
select id, organizer_id, name, description, published_at, total_price_cents, location, starts_at, duration_minutes, max_players, max_waitlist_size, max_guests_per_player, created_at, updated_at from games where id = ?
`

func (q *Queries) GameGetById(ctx context.Context, id string) (Game, error) {
	row := q.db.QueryRowContext(ctx, gameGetById, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.OrganizerID,
		&i.Name,
		&i.Description,
		&i.PublishedAt,
		&i.TotalPriceCents,
		&i.Location,
		&i.StartsAt,
		&i.DurationMinutes,
		&i.MaxPlayers,
		&i.MaxWaitlistSize,
		&i.MaxGuestsPerPlayer,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const gameListByUser = `-- name: GameListByUser :many
select
  id,
  name,
  location,
  starts_at,
  published_at,
  updated_at,
  organizer_id = ? as is_organizer
from games
where organizer_id = ?
order by coalesce(published_at, updated_at) desc
limit ? offset ?
`

type GameListByUserParams struct {
	OrganizerID   int64
	OrganizerID_2 int64
	Limit         int64
	Offset        int64
}

type GameListByUserRow struct {
	ID          string
	Name        string
	Location    sql.NullString
	StartsAt    sql.NullTime
	PublishedAt sql.NullTime
	UpdatedAt   time.Time
	IsOrganizer bool
}

func (q *Queries) GameListByUser(ctx context.Context, arg GameListByUserParams) ([]GameListByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, gameListByUser,
		arg.OrganizerID,
		arg.OrganizerID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameListByUserRow
	for rows.Next() {
		var i GameListByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.StartsAt,
			&i.PublishedAt,
			&i.UpdatedAt,
			&i.IsOrganizer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gameUpdate = `-- name: GameUpdate :exec
update games
set
  name = coalesce(?1, name),
  description = coalesce(?2, description),
  published_at = case
    when cast(?3 as boolean) then null
    else coalesce(?4, published_at)
  end,
  total_price_cents = coalesce(?5, total_price_cents),
  location = coalesce(?6, location),
  starts_at = coalesce(?7, starts_at),
  duration_minutes = coalesce(nullif(cast(?8 as integer), 0), duration_minutes),
  max_players = coalesce(nullif(cast(?9 as integer), 0), max_players),
  max_waitlist_size = coalesce(?10, max_waitlist_size),
  max_guests_per_player = coalesce(?11, max_guests_per_player),
  updated_at = current_timestamp
where id = ?12
`

type GameUpdateParams struct {
	Name               string
	Description        sql.NullString
	ClearPublishedAt   bool
	PublishedAt        sql.NullTime
	TotalPriceCents    int64
	Location           sql.NullString
	StartsAt           sql.NullTime
	DurationMinutes    int64
	MaxPlayers         int64
	MaxWaitlistSize    int64
	MaxGuestsPerPlayer int64
	ID                 string
}

func (q *Queries) GameUpdate(ctx context.Context, arg GameUpdateParams) error {
	_, err := q.db.ExecContext(ctx, gameUpdate,
		arg.Name,
		arg.Description,
		arg.ClearPublishedAt,
		arg.PublishedAt,
		arg.TotalPriceCents,
		arg.Location,
		arg.StartsAt,
		arg.DurationMinutes,
		arg.MaxPlayers,
		arg.MaxWaitlistSize,
		arg.MaxGuestsPerPlayer,
		arg.ID,
	)
	return err
}
