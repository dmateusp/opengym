// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const gameCountByUser = `-- name: GameCountByUser :one
select count(*)
from games
left join game_participants
  on games.id = game_participants.game_id and game_participants.user_id = ?1
where games.organizer_id =?1 or game_participants.user_id is not null
`

func (q *Queries) GameCountByUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, gameCountByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const gameCreate = `-- name: GameCreate :one
insert into games(
  id,
  organizer_id,
  name,
  description,
  published_at,
  total_price_cents,
  location,
  starts_at,
  duration_minutes,
  max_players,
  max_waitlist_size,
  max_guests_per_player,
  game_spots_left,
  waitlist_spots_left
) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
returning id, organizer_id, name, description, published_at, total_price_cents, location, starts_at, duration_minutes, max_players, max_waitlist_size, max_guests_per_player, game_spots_left, waitlist_spots_left, created_at, updated_at
`

type GameCreateParams struct {
	ID                 string
	OrganizerID        int64
	Name               string
	Description        sql.NullString
	PublishedAt        sql.NullTime
	TotalPriceCents    int64
	Location           sql.NullString
	StartsAt           sql.NullTime
	DurationMinutes    int64
	MaxPlayers         int64
	MaxWaitlistSize    int64
	MaxGuestsPerPlayer int64
	GameSpotsLeft      int64
	WaitlistSpotsLeft  int64
}

func (q *Queries) GameCreate(ctx context.Context, arg GameCreateParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, gameCreate,
		arg.ID,
		arg.OrganizerID,
		arg.Name,
		arg.Description,
		arg.PublishedAt,
		arg.TotalPriceCents,
		arg.Location,
		arg.StartsAt,
		arg.DurationMinutes,
		arg.MaxPlayers,
		arg.MaxWaitlistSize,
		arg.MaxGuestsPerPlayer,
		arg.GameSpotsLeft,
		arg.WaitlistSpotsLeft,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.OrganizerID,
		&i.Name,
		&i.Description,
		&i.PublishedAt,
		&i.TotalPriceCents,
		&i.Location,
		&i.StartsAt,
		&i.DurationMinutes,
		&i.MaxPlayers,
		&i.MaxWaitlistSize,
		&i.MaxGuestsPerPlayer,
		&i.GameSpotsLeft,
		&i.WaitlistSpotsLeft,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const gameGetById = `-- name: GameGetById :one
select id, organizer_id, name, description, published_at, total_price_cents, location, starts_at, duration_minutes, max_players, max_waitlist_size, max_guests_per_player, game_spots_left, waitlist_spots_left, created_at, updated_at
from games
where games.id = ?
`

func (q *Queries) GameGetById(ctx context.Context, id string) (Game, error) {
	row := q.db.QueryRowContext(ctx, gameGetById, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.OrganizerID,
		&i.Name,
		&i.Description,
		&i.PublishedAt,
		&i.TotalPriceCents,
		&i.Location,
		&i.StartsAt,
		&i.DurationMinutes,
		&i.MaxPlayers,
		&i.MaxWaitlistSize,
		&i.MaxGuestsPerPlayer,
		&i.GameSpotsLeft,
		&i.WaitlistSpotsLeft,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const gameGetByIdWithOrganizer = `-- name: GameGetByIdWithOrganizer :one
select
  games.id, games.organizer_id, games.name, games.description, games.published_at, games.total_price_cents, games.location, games.starts_at, games.duration_minutes, games.max_players, games.max_waitlist_size, games.max_guests_per_player, games.game_spots_left, games.waitlist_spots_left, games.created_at, games.updated_at,
  users.id, users.name, users.email, users.photo, users.created_at, users.updated_at, users.is_demo
from games
join users
  on users.id = games.organizer_id
where games.id = ?
`

type GameGetByIdWithOrganizerRow struct {
	Game Game
	User User
}

func (q *Queries) GameGetByIdWithOrganizer(ctx context.Context, id string) (GameGetByIdWithOrganizerRow, error) {
	row := q.db.QueryRowContext(ctx, gameGetByIdWithOrganizer, id)
	var i GameGetByIdWithOrganizerRow
	err := row.Scan(
		&i.Game.ID,
		&i.Game.OrganizerID,
		&i.Game.Name,
		&i.Game.Description,
		&i.Game.PublishedAt,
		&i.Game.TotalPriceCents,
		&i.Game.Location,
		&i.Game.StartsAt,
		&i.Game.DurationMinutes,
		&i.Game.MaxPlayers,
		&i.Game.MaxWaitlistSize,
		&i.Game.MaxGuestsPerPlayer,
		&i.Game.GameSpotsLeft,
		&i.Game.WaitlistSpotsLeft,
		&i.Game.CreatedAt,
		&i.Game.UpdatedAt,
		&i.User.ID,
		&i.User.Name,
		&i.User.Email,
		&i.User.Photo,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.IsDemo,
	)
	return i, err
}

const gameListByUser = `-- name: GameListByUser :many
select
  games.id,
  games.name,
  games.location,
  games.starts_at,
  games.published_at,
  games.updated_at,
  games.organizer_id = ?1 as is_organizer,
  users.id, users.name, users.email, users.photo, users.created_at, users.updated_at, users.is_demo
from games
left join game_participants
  on games.id = game_participants.game_id and game_participants.user_id = ?1
join users
  on users.id = games.organizer_id
where games.organizer_id = ?1 or game_participants.user_id is not null
order by coalesce(games.published_at, games.updated_at) desc
limit ?3 offset ?2
`

type GameListByUserParams struct {
	UserID int64
	Offset int64
	Limit  int64
}

type GameListByUserRow struct {
	ID          string
	Name        string
	Location    sql.NullString
	StartsAt    sql.NullTime
	PublishedAt sql.NullTime
	UpdatedAt   time.Time
	IsOrganizer bool
	User        User
}

func (q *Queries) GameListByUser(ctx context.Context, arg GameListByUserParams) ([]GameListByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, gameListByUser, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameListByUserRow
	for rows.Next() {
		var i GameListByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.StartsAt,
			&i.PublishedAt,
			&i.UpdatedAt,
			&i.IsOrganizer,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.Photo,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.IsDemo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gameUpdate = `-- name: GameUpdate :exec
update games
set
  name = coalesce(?1, name),
  description = coalesce(?2, description),
  published_at = case
    when cast(?3 as boolean) then null
    else coalesce(?4, published_at)
  end,
  total_price_cents = coalesce(?5, total_price_cents),
  location = coalesce(?6, location),
  starts_at = coalesce(?7, starts_at),
  duration_minutes = coalesce(nullif(cast(?8 as integer), 0), duration_minutes),
  max_players = coalesce(nullif(cast(?9 as integer), 0), max_players),
  max_waitlist_size = coalesce(?10, max_waitlist_size),
  max_guests_per_player = coalesce(?11, max_guests_per_player),
  game_spots_left = coalesce(?12, game_spots_left),
  waitlist_spots_left = coalesce(?13, waitlist_spots_left),
  updated_at = current_timestamp
where id = ?14
`

type GameUpdateParams struct {
	Name               string
	Description        sql.NullString
	ClearPublishedAt   bool
	PublishedAt        sql.NullTime
	TotalPriceCents    int64
	Location           sql.NullString
	StartsAt           sql.NullTime
	DurationMinutes    int64
	MaxPlayers         sql.NullInt64
	MaxWaitlistSize    sql.NullInt64
	MaxGuestsPerPlayer sql.NullInt64
	GameSpotsLeft      sql.NullInt64
	WaitlistSpotsLeft  sql.NullInt64
	ID                 string
}

func (q *Queries) GameUpdate(ctx context.Context, arg GameUpdateParams) error {
	_, err := q.db.ExecContext(ctx, gameUpdate,
		arg.Name,
		arg.Description,
		arg.ClearPublishedAt,
		arg.PublishedAt,
		arg.TotalPriceCents,
		arg.Location,
		arg.StartsAt,
		arg.DurationMinutes,
		arg.MaxPlayers,
		arg.MaxWaitlistSize,
		arg.MaxGuestsPerPlayer,
		arg.GameSpotsLeft,
		arg.WaitlistSpotsLeft,
		arg.ID,
	)
	return err
}
