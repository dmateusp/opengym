// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: participants.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const participantsList = `-- name: ParticipantsList :many
select
    users.id = ?1 as is_organizer,
    game_participants.user_id, game_participants.game_id, game_participants.created_at, game_participants.updated_at, game_participants.going_updated_at, game_participants.going, game_participants.confirmed_at,
    users.id, users.name, users.email, users.photo, users.created_at, users.updated_at, users.is_demo
from game_participants
join users on game_participants.user_id = users.id
where game_participants.game_id = ?2
order by
    1 desc, -- if the user is the organizer, they should have priority
    game_participants.going_updated_at asc
`

type ParticipantsListParams struct {
	OrganizerID int64
	GameID      string
}

type ParticipantsListRow struct {
	IsOrganizer     bool
	GameParticipant GameParticipant
	User            User
}

func (q *Queries) ParticipantsList(ctx context.Context, arg ParticipantsListParams) ([]ParticipantsListRow, error) {
	rows, err := q.db.QueryContext(ctx, participantsList, arg.OrganizerID, arg.GameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParticipantsListRow
	for rows.Next() {
		var i ParticipantsListRow
		if err := rows.Scan(
			&i.IsOrganizer,
			&i.GameParticipant.UserID,
			&i.GameParticipant.GameID,
			&i.GameParticipant.CreatedAt,
			&i.GameParticipant.UpdatedAt,
			&i.GameParticipant.GoingUpdatedAt,
			&i.GameParticipant.Going,
			&i.GameParticipant.ConfirmedAt,
			&i.User.ID,
			&i.User.Name,
			&i.User.Email,
			&i.User.Photo,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.IsDemo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const participantsUpsert = `-- name: ParticipantsUpsert :exec
insert into game_participants(
    user_id,
    game_id,
    going,
    going_updated_at,
    confirmed_at
) values (?, ?, ?, ?, ?)
on conflict(user_id, game_id) do update set
    updated_at = current_timestamp,
    going = coalesce(excluded.going, game_participants.going),
    going_updated_at = iif(excluded.going = game_participants.going, game_participants.going_updated_at, excluded.going_updated_at),
    confirmed_at = coalesce(excluded.confirmed_at, game_participants.confirmed_at)
`

type ParticipantsUpsertParams struct {
	UserID         int64
	GameID         string
	Going          sql.NullBool
	GoingUpdatedAt time.Time
	ConfirmedAt    sql.NullTime
}

func (q *Queries) ParticipantsUpsert(ctx context.Context, arg ParticipantsUpsertParams) error {
	_, err := q.db.ExecContext(ctx, participantsUpsert,
		arg.UserID,
		arg.GameID,
		arg.Going,
		arg.GoingUpdatedAt,
		arg.ConfirmedAt,
	)
	return err
}
